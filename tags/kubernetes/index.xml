<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kubernetes on JO Jaeyoung | 조재영</title>
    <link>https://jaese.github.io/tags/kubernetes/</link>
    <description>Recent content in kubernetes on JO Jaeyoung | 조재영</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Apr 2022 11:57:18 +0900</lastBuildDate><atom:link href="https://jaese.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stop Computer Networking</title>
      <link>https://jaese.github.io/posts/stop-computer-networking/</link>
      <pubDate>Tue, 05 Apr 2022 11:57:18 +0900</pubDate>
      
      <guid>https://jaese.github.io/posts/stop-computer-networking/</guid>
      <description>While I was following the Kubernetes The Hard Way on the laptop with Vagrant VMs, I was reminded of the conviction that I had been holding: an application generally should not deal with computer networking. That is, it should not concern with host addresses or ports or HTTP protocols or anything. Instead, it should work above a messaging abstraction provided by message brokers like NATS or Kafka or such.
If the application requires low network latency such as video streaming, then it would need to deal with networking.</description>
    </item>
    
    <item>
      <title>Setting up a K3S cluster</title>
      <link>https://jaese.github.io/posts/hello-k3s/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jaese.github.io/posts/hello-k3s/</guid>
      <description>I wanted to set up a Kubernetes cluster on my networking lab that consists of three RPis and a PC, and run some actual workload. I used K3S, a lightweight Kubernetes distribution, because it seemed to be the one to go to for running Kubernetes on RPis, ex. Jeff Geerling&amp;rsquo;s video on installing K3S. For image registry, I tried Harbor open source registry v2.4.1. The cluster ingress is fronted by a reverse proxy.</description>
    </item>
    
  </channel>
</rss>
