<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Stop Computer Networking</title>
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/base-min.css">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/pure-min.css" integrity="sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-responsive-min.css">

  <script src="https://kit.fontawesome.com/b038bb8731.js" crossorigin="anonymous"></script>

  <link rel="alternate" title="JO Jaeyoung" type="application/feed+json" href="https://jaese.github.io/feed.json" />

  
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Stop Computer Networking",
  
  "datePublished": "2022-04-05T11:57:18+09:00",
  "dateModified": "2022-04-05T11:57:18+09:00",
  "author": {
    "@type": "Person",
    "url": "https://jaese.github.io/",
    "name": "jaese"
  },
  "mainEntityOfPage": { "@type": "Webpage" },
  "description": "While I was following the Kubernetes The Hard Way on the laptop with Vagrant VMs, I was reminded of the conviction that I had been holding: an application generally should not deal with computer networking. That is, it should not concern with host addresses or ports or HTTP protocols or anything. Instead, it should work above a messaging abstraction provided by message brokers like NATS or Kafka or such.\nIf the application requires low network latency such as video streaming, then it would need to deal with networking.",
  "keywords": [
    
    
    "networking"
    
    ,
    
    "kubernetes"
    
  ]
}
</script>


</head>

<body>
  <style>
    body {
      margin: 0;
    }

     
  </style>

  <div class="wrap pure-g">
    <nav class="profile pure-u-1 pure-u-md-1-4">
      <h3><a href="/">JO Jaeyoung<br>조재영</a></h3>
      <img class="pure-img" style="width:60%" src="/profile.png" />

      <ul>
        <li><a href="/resume.pdf"><i class="fa fa-file-text-o"></i> CV</a></li>
        <li><a href="https://jaese.github.io/feed.json"><i class="fas fa-rss-square"></i> JSON Feed</a></li>
        <li><a href="https://github.com/jaese"><i class="fab fa-github"></i> GitHub</a></li>
        <li><a href="https://www.kaggle.com/jaeyoungse"><i class="fab fa-kaggle"></i> Kaggle</a></li>
        <li><a href="https://www.linkedin.com/in/jaeyoung-jo-64b2a6148/"><i class="fab fa-linkedin"></i> LinkedIn</a></li>
        <li><a href="https://www.instagram.com/jaeyoung.se/"><i class="fab fa-instagram"></i> Instagram</a></li>
        <li><a href="mailto:jojaeyoung.se@gmail.com"><i class="fas fa-envelope-square"></i> Email</a></li>
        <li><a href="https://keybase.io/jaese"><i class="fab fa-keybase"></i> Keybase</a></li>
        <li><a href="gemini://jaeyoung.se"><i class="fas fa-rocket"></i> Gemini Capsule</a></li>
      </ul>

      <p>
        My role model is Iron Man.
      </p>

      <p class="time">
        UTC - TAI =<br><a href="https://hpiers.obspm.fr/iers/bul/bulc/bulletinc.dat">-37 s</a>
        <br>
        <br>
        TIME_TAI = <span class="time-tai">?</span>
        <br>
        (based on browser time)
      </p>

      
    </nav>
    <div class="content pure-u-1 pure-u-md-3-4">
      
<main>
  <article class="content">
      <h1>Stop Computer Networking</h1>
      <time datetime="2022-04-05T11:57:18">2022-04-05T11:57:18</time>
      <p>tags: [networking kubernetes]</p>
      
      
      <p>While I was following <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">the Kubernetes The Hard Way</a> on the laptop with Vagrant VMs, I was reminded of the conviction that I had been holding: an application generally should not deal with computer networking. That is, it should not concern with host addresses or ports or HTTP protocols or anything. Instead, it should work above a messaging abstraction provided by message brokers like <a href="https://nats.io">NATS</a> or Kafka or such.</p>
<p>If the application requires low network latency such as video streaming, then it would need to deal with networking. But for an application that processes JSON messages and operates near the business level, the complexity of dealing with networking is simply unjustified. Ideally, it would only need to know how to connect to a message broker and get all messaging done through it. It should even dispense with DNS. Applications that rely on DNS for service discovery have a tendency of being subtly broken.</p>
<p>Alas, a saner networking abstraction is not a norm, and that means I have to configure network overlay and DNS server, and go through all their platform-specific details, to have a usable cluster.</p>
<p>By the way, I uploaded the scripts and config files following the Kubernetes The Hard Way to <a href="https://github.com/jaese/jaese-kubernetes-the-hard-way">https://github.com/jaese/jaese-kubernetes-the-hard-way</a></p>

    <style>
      .content p {
        line-height: 130%;
      }

      pre {
        padding: 1rem;
      }

      .content img {
        max-width: 100%;
        height: auto;
      }
    </style>
  </article>
  
</main>

<script src="https://giscus.app/client.js"
        data-repo="jaese/jaese.github.io"
        data-repo-id="R_kgDOGU2PdQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOGU2Pdc4CA-sN"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>



    </div>
  </div>
  <style>
    nav.profile {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 200px;
       

      box-sizing: border-box;
    }

    nav.profile ul {
      list-style: none;
      width: 100%;
    }

    nav.profile li {
      line-height: 20px;
    }
    nav.profile .fab, .fas {
      width: 15px;
    }
    nav.profile a {
      color: #333333;
      text-decoration: none;
    }

    .time {
      text-align: center;
    }
    .time a {
      font-weight: bold;
    }

    div.content {
      max-width: 800px;
       

      padding: 0 0.5rem;

      box-sizing: border-box;
    }

 
  </style>



  <script type="module">
    const timeTAIElement = document.querySelector('.time-tai');
    const utcTAIOffset = -37;

    const updateTime = () => {
      const local = new Date();
      const utc = new Date(local.getTime() + local.getTimezoneOffset() * 60 * 1000);
      const tai = utc.getTime() - (utcTAIOffset * 1000);
      timeTAIElement.textContent = Math.round(tai / 1000);

      let ms = local.getTime() % 1000;
      if (ms > 500) {
        ms -= 1000;
      };
      
    };
    updateTime();

  </script>
</body>

</html>
